const translations = {
  en: {
    navHome: 'Home',
    navHow: 'How it works',
    navExperts: 'Experts',
    navFamily: 'Family membership',
    navLogin: 'Login',
    navSignup: 'Join the family',
    navDashboard: 'Dashboard',
    navCrm: 'CRM',
    navSessions: 'Sessions',
    navPlan: 'Family plan',
    navProfile: 'Profile',
    navLogout: 'Logout',
    landingEyebrow: 'Consultation web app',
    landingTitle: 'Care for your family, guided by trusted experts.',
    landingSubtitle: 'Book consultations, secure your records, and keep everyone aligned with one bilingual experience.',
    ctaJoin: 'Join the family',
    ctaLogin: 'I already have an account',
    trustSecure: 'Secure by design',
    trustPrivate: 'Private consultations',
    trustVerified: 'Verified professionals',
    heroCardTitle: 'Your next consultation',
    heroCardStatus: 'Family member',
    heroCardWhen: 'When',
    heroCardWho: 'With',
    heroCardType: 'Type',
    heroCardTypeValue: 'Family wellness review',
    heroCardButton: 'Reserve your slot',
    valueTitle1: 'Expert-led consultations',
    valueBody1: 'Meet bilingual specialists who guide your family with clarity and empathy.',
    valueTitle2: 'Secure shared plans',
    valueBody2: 'Keep every recommendation in one encrypted, easy-to-share space.',
    valueTitle3: 'Always-on support',
    valueBody3: 'Message your care team and track next steps without the chaos.',
    howTitle: 'How it works',
    howStepTitle1: 'Create your family profile',
    howStepBody1: 'Register once and invite everyone who shares the journey.',
    howStepTitle2: 'Choose a specialist',
    howStepBody2: 'Pick the expert that matches your needs, in French or English.',
    howStepTitle3: 'Start the consultation',
    howStepBody3: 'Join securely, then track follow-ups with reminders and notes.',
    familyTitle: 'Membership that keeps you together',
    familyBody: 'To access consultations, your family needs a secure account. Create it once and keep every session organized.',
    familyBullet1: 'Protected access for each family member',
    familyBullet2: 'Simple SQL-backed login with secure hashing',
    familyBullet3: 'Upgrade-ready for serverless databases',
    membershipCardTitle: 'Ready to join?',
    membershipCardBody: 'Sign up in under two minutes and meet your care team.',
    membershipCardCta: 'Create my account',
    membershipCardAlt: 'I already have an account',
    dashboardEyebrow: 'Family space',
    dashboardTitle: 'Welcome back to your consultation hub.',
    dashboardSubtitle: 'Review upcoming sessions, share updates, and keep your care plan consistent.',
    dashboardCta: 'View next session',
    dashboardSecondary: 'Update family plan',
    statusTitle: 'Family status',
    statusTag: 'Active member',
    statusNext: 'Next consultation',
    statusChannel: 'Channel',
    statusChannelValue: 'Secure video room',
    statusCoach: 'Lead specialist',
    sessionCardTitle: 'Upcoming sessions',
    sessionCardBody: 'Confirm attendance, add notes, and set reminders for each family member.',
    sessionCardCta: 'Manage sessions',
    messagesCardTitle: 'Secure messages',
    messagesCardBody: 'Send updates to your care team without leaving the app.',
    messagesCardCta: 'Start a message',
    resourcesCardTitle: 'Family resources',
    resourcesCardBody: 'Download bilingual guides and follow personalized recommendations.',
    resourcesCardCta: 'View resources',
    crmEyebrow: 'CRM focus',
    crmTitle: 'Booking CRM that protects weekly revenue.',
    crmSubtitle: 'See where prospects drop, recover missed quotes, and align every follow-up from one dashboard.',
    crmRefresh: 'Refresh data',
    crmNewBooking: 'New booking',
    crmMetricsTitle: 'Pipeline snapshot',
    crmMetricsTag: 'This week',
    crmMetricLeads: 'Active leads',
    crmMetricQuotes: 'Quotes pending',
    crmMetricRevenue: 'Revenue at risk',
    crmMetricConversion: 'Conversion rate',
    crmPipelineTitle: 'Lead stages',
    crmPipelineTag: 'Last 14 days',
    crmTasksTitle: 'Follow-up focus',
    crmTasksTag: 'Priority',
    crmTaskDue: 'Due',
    crmTaskOwner: 'Owner',
    crmBookingsTitle: 'Booking requests',
    crmBookingsSubtitle: 'Track quote status, next steps, and ownership for every request.',
    crmImport: 'Import leads',
    crmTableClient: 'Client',
    crmTableService: 'Service',
    crmTableStatus: 'Status',
    crmTableValue: 'Value',
    crmTableOwner: 'Owner',
    crmTableActions: 'Actions',
    crmActionEdit: 'Edit',
    crmActionDelete: 'Delete',
    crmFormTitle: 'Create a booking',
    crmFormClientLabel: 'Client',
    crmFormClientPlaceholder: 'Client name',
    crmFormServiceLabel: 'Service',
    crmFormServicePlaceholder: 'Cleaning service',
    crmFormDateLabel: 'Preferred date',
    crmFormValueLabel: 'Estimated value',
    crmFormValuePlaceholder: '0',
    crmFormStatusLabel: 'Status',
    crmFormOwnerLabel: 'Owner',
    crmFormOwnerPlaceholder: 'Account manager',
    crmFormSourceLabel: 'Source',
    crmFormSourcePlaceholder: 'Instagram, referral',
    crmFormNextStepLabel: 'Next step',
    crmFormNextStepPlaceholder: 'Follow-up call',
    crmFormSubmit: 'Save booking',
    crmFormUpdate: 'Update booking',
    crmFormCancel: 'Cancel',
    crmEmptyState: 'No booking requests yet. Add the first opportunity.',
    crmStatusNew: 'New',
    crmStatusQualified: 'Qualified',
    crmStatusQuoteSent: 'Quote sent',
    crmStatusAwaiting: 'Awaiting response',
    crmStatusWon: 'Won',
    crmStatusLost: 'Lost',
    planTitle: 'Your family plan, always within reach',
    planBody: 'Track goals, update shared notes, and keep every caregiver aligned.',
    planItemTitle1: 'Weekly wellness check-ins',
    planItemBody1: 'Review progress together every Friday.',
    planItemTitle2: 'Private records vault',
    planItemBody2: 'Securely store notes and consultation summaries.',
    planItemTitle3: 'Shared family access',
    planItemBody3: 'Invite trusted caregivers and manage permissions.',
    loginTitle: 'Welcome back',
    loginSubtitle: 'Sign in to access your family consultation hub.',
    signupTitle: 'Create your family account',
    signupSubtitle: 'Register once to access consultations in English or French.',
    labelUsername: 'Username',
    labelPassword: 'Password',
    labelRemember: 'Remember me',
    loginButton: 'Login',
    signupButton: 'Create account',
    placeholderUsername: 'Enter your username',
    placeholderPassword: 'Enter your password',
    oauthTitle: 'Or continue with',
    oauthGoogle: 'Sign in with Google',
    oauthGithub: 'Sign in with GitHub',
    loginSwitchText: "Don't have an account?",
    loginSwitchLink: 'Join the family',
    signupSwitchText: 'Already a member?',
    signupSwitchLink: 'Login',
    authRequired: 'Please sign in to access family-only content.',
    footerCopy: 'Â© 2024 CareBridge Consultation. All rights reserved.'
  },
  fr: {
    navHome: 'Accueil',
    navHow: 'Fonctionnement',
    navExperts: 'Experts',
    navFamily: 'AdhÃ©sion famille',
    navLogin: 'Connexion',
    navSignup: 'Rejoindre la famille',
    navDashboard: 'Tableau de bord',
    navCrm: 'CRM',
    navSessions: 'SÃ©ances',
    navPlan: 'Plan familial',
    navProfile: 'Profil',
    navLogout: 'DÃ©connexion',
    landingEyebrow: 'Application de consultation',
    landingTitle: 'Prenez soin de votre famille avec des experts de confiance.',
    landingSubtitle: 'RÃ©servez des consultations, sÃ©curisez vos dossiers et restez alignÃ©s avec une expÃ©rience bilingue.',
    ctaJoin: 'Rejoindre la famille',
    ctaLogin: "J'ai dÃ©jÃ  un compte",
    trustSecure: 'SÃ©curitÃ© intÃ©grÃ©e',
    trustPrivate: 'Consultations privÃ©es',
    trustVerified: 'Professionnels vÃ©rifiÃ©s',
    heroCardTitle: 'Votre prochaine consultation',
    heroCardStatus: 'Membre de la famille',
    heroCardWhen: 'Quand',
    heroCardWho: 'Avec',
    heroCardType: 'Type',
    heroCardTypeValue: 'Bilan bien-Ãªtre familial',
    heroCardButton: 'RÃ©server mon crÃ©neau',
    valueTitle1: 'Consultations guidÃ©es par des experts',
    valueBody1: 'Rencontrez des spÃ©cialistes bilingues qui accompagnent votre famille avec clartÃ© et empathie.',
    valueTitle2: 'Plans partagÃ©s sÃ©curisÃ©s',
    valueBody2: 'Conservez chaque recommandation dans un espace chiffrÃ© et facile Ã  partager.',
    valueTitle3: 'Support toujours disponible',
    valueBody3: 'Envoyez des messages Ã  votre Ã©quipe sans perdre le fil.',
    howTitle: 'Fonctionnement',
    howStepTitle1: 'CrÃ©ez votre profil familial',
    howStepBody1: 'Inscrivez-vous une fois et invitez les proches concernÃ©s.',
    howStepTitle2: 'Choisissez un spÃ©cialiste',
    howStepBody2: 'SÃ©lectionnez lâ€™expert qui rÃ©pond Ã  vos besoins, en franÃ§ais ou en anglais.',
    howStepTitle3: 'Lancez la consultation',
    howStepBody3: 'Rejoignez en toute sÃ©curitÃ© puis suivez les actions et rappels.',
    familyTitle: 'Une adhÃ©sion qui vous rassemble',
    familyBody: 'Pour accÃ©der aux consultations, votre famille a besoin dâ€™un compte sÃ©curisÃ©. CrÃ©ez-le une fois et organisez chaque sÃ©ance.',
    familyBullet1: 'AccÃ¨s protÃ©gÃ© pour chaque membre',
    familyBullet2: 'Connexion SQL simple avec hachage sÃ©curisÃ©',
    familyBullet3: 'PrÃªt pour une base serverless',
    membershipCardTitle: 'PrÃªt Ã  nous rejoindre ?',
    membershipCardBody: 'Inscrivez-vous en moins de deux minutes et rencontrez votre Ã©quipe.',
    membershipCardCta: 'CrÃ©er mon compte',
    membershipCardAlt: "J'ai dÃ©jÃ  un compte",
    dashboardEyebrow: 'Espace famille',
    dashboardTitle: 'Bon retour dans votre espace de consultation.',
    dashboardSubtitle: 'Consultez vos sÃ©ances, partagez des mises Ã  jour et gardez le plan en place.',
    dashboardCta: 'Voir la prochaine sÃ©ance',
    dashboardSecondary: 'Mettre Ã  jour le plan',
    statusTitle: 'Statut familial',
    statusTag: 'Membre actif',
    statusNext: 'Prochaine consultation',
    statusChannel: 'Canal',
    statusChannelValue: 'Salle vidÃ©o sÃ©curisÃ©e',
    statusCoach: 'SpÃ©cialiste rÃ©fÃ©rent',
    sessionCardTitle: 'SÃ©ances Ã  venir',
    sessionCardBody: 'Confirmez la prÃ©sence, ajoutez des notes et des rappels.',
    sessionCardCta: 'GÃ©rer les sÃ©ances',
    messagesCardTitle: 'Messages sÃ©curisÃ©s',
    messagesCardBody: "Envoyez des mises Ã  jour Ã  votre Ã©quipe de soins directement.",
    messagesCardCta: 'DÃ©marrer un message',
    resourcesCardTitle: 'Ressources familiales',
    resourcesCardBody: 'TÃ©lÃ©chargez des guides bilingues et suivez les recommandations.',
    resourcesCardCta: 'Voir les ressources',
    crmEyebrow: 'Focus CRM',
    crmTitle: 'Un CRM de rÃ©servation pour protÃ©ger le chiffre hebdomadaire.',
    crmSubtitle: 'RepÃ©rez oÃ¹ les prospects dÃ©crochent, rÃ©cupÃ©rez les devis et alignez chaque suivi.',
    crmRefresh: 'RafraÃ®chir les donnÃ©es',
    crmNewBooking: 'Nouvelle demande',
    crmMetricsTitle: 'InstantanÃ© du pipeline',
    crmMetricsTag: 'Cette semaine',
    crmMetricLeads: 'Prospects actifs',
    crmMetricQuotes: 'Devis en attente',
    crmMetricRevenue: 'Revenu Ã  risque',
    crmMetricConversion: 'Taux de conversion',
    crmPipelineTitle: 'Ã‰tapes du pipeline',
    crmPipelineTag: '14 derniers jours',
    crmTasksTitle: 'Suivis prioritaires',
    crmTasksTag: 'PrioritÃ©',
    crmTaskDue: 'Ã‰chÃ©ance',
    crmTaskOwner: 'Responsable',
    crmBookingsTitle: 'Demandes de rÃ©servation',
    crmBookingsSubtitle: 'Suivez le statut des devis, les prochaines Ã©tapes et les responsables.',
    crmImport: 'Importer des leads',
    crmTableClient: 'Client',
    crmTableService: 'Service',
    crmTableStatus: 'Statut',
    crmTableValue: 'Valeur',
    crmTableOwner: 'Responsable',
    crmTableActions: 'Actions',
    crmActionEdit: 'Modifier',
    crmActionDelete: 'Supprimer',
    crmFormTitle: 'CrÃ©er une demande',
    crmFormClientLabel: 'Client',
    crmFormClientPlaceholder: 'Nom du client',
    crmFormServiceLabel: 'Service',
    crmFormServicePlaceholder: 'Service de nettoyage',
    crmFormDateLabel: 'Date souhaitÃ©e',
    crmFormValueLabel: 'Valeur estimÃ©e',
    crmFormValuePlaceholder: '0',
    crmFormStatusLabel: 'Statut',
    crmFormOwnerLabel: 'Responsable',
    crmFormOwnerPlaceholder: 'Gestionnaire',
    crmFormSourceLabel: 'Source',
    crmFormSourcePlaceholder: 'Instagram, recommandation',
    crmFormNextStepLabel: 'Prochaine Ã©tape',
    crmFormNextStepPlaceholder: 'Appel de suivi',
    crmFormSubmit: 'Enregistrer',
    crmFormUpdate: 'Mettre Ã  jour',
    crmFormCancel: 'Annuler',
    crmEmptyState: 'Aucune demande pour le moment. Ajoutez la premiÃ¨re opportunitÃ©.',
    crmStatusNew: 'Nouveau',
    crmStatusQualified: 'QualifiÃ©',
    crmStatusQuoteSent: 'Devis envoyÃ©',
    crmStatusAwaiting: 'En attente de rÃ©ponse',
    crmStatusWon: 'GagnÃ©',
    crmStatusLost: 'Perdu',
    planTitle: 'Votre plan familial Ã  portÃ©e de main',
    planBody: 'Suivez les objectifs, mettez Ã  jour les notes et alignez les aidants.',
    planItemTitle1: 'Points hebdomadaires',
    planItemBody1: 'Faites le point ensemble chaque vendredi.',
    planItemTitle2: 'Coffre de dossiers privÃ©s',
    planItemBody2: 'Stockez en sÃ©curitÃ© les notes et rÃ©sumÃ©s.',
    planItemTitle3: 'AccÃ¨s partagÃ©',
    planItemBody3: 'Invitez des aidants et gÃ©rez les autorisations.',
    loginTitle: 'Bon retour',
    loginSubtitle: 'Connectez-vous pour accÃ©der Ã  votre espace familial.',
    signupTitle: 'CrÃ©ez votre compte familial',
    signupSubtitle: 'Inscrivez-vous pour accÃ©der aux consultations en franÃ§ais ou en anglais.',
    labelUsername: 'Identifiant',
    labelPassword: 'Mot de passe',
    labelRemember: 'Se souvenir de moi',
    loginButton: 'Connexion',
    signupButton: 'CrÃ©er un compte',
    placeholderUsername: 'Entrez votre identifiant',
    placeholderPassword: 'Entrez votre mot de passe',
    oauthTitle: 'Ou continuer avec',
    oauthGoogle: 'Se connecter avec Google',
    oauthGithub: 'Se connecter avec GitHub',
    loginSwitchText: 'Pas encore de compte ?',
    loginSwitchLink: 'Rejoignez la famille',
    signupSwitchText: 'DÃ©jÃ  membre ?',
    signupSwitchLink: 'Connexion',
    authRequired: 'Veuillez vous connecter pour accÃ©der Ã  lâ€™espace famille.',
    footerCopy: 'Â© 2024 CareBridge Consultation. Tous droits rÃ©servÃ©s.'
  }
};

const LANGUAGE_STORAGE_KEY = 'consultationLanguage';
let currentLanguage = localStorage.getItem(LANGUAGE_STORAGE_KEY) || 'en';

function applyTranslations() {
  const dictionary = translations[currentLanguage] || translations.en;

  document.documentElement.setAttribute('lang', currentLanguage);

  document.querySelectorAll('[data-i18n]').forEach((element) => {
    const key = element.dataset.i18n;
    if (dictionary[key]) {
      element.textContent = dictionary[key];
    }
  });

  document.querySelectorAll('[data-i18n-placeholder]').forEach((element) => {
    const key = element.dataset.i18nPlaceholder;
    if (dictionary[key]) {
      element.setAttribute('placeholder', dictionary[key]);
    }
  });

  document.querySelectorAll('[data-auth-banner]').forEach((element) => {
    element.querySelector('span')?.setAttribute('data-i18n', 'authRequired');
  });
}

function updateLanguageToggle() {
  const toggle = document.querySelector('[data-lang-toggle]');
  if (!toggle) return;
  toggle.setAttribute('data-current-lang', currentLanguage);
  toggle.setAttribute('aria-pressed', currentLanguage === 'fr');
}

function setLanguage(language) {
  currentLanguage = language;
  localStorage.setItem(LANGUAGE_STORAGE_KEY, currentLanguage);
  applyTranslations();
  updateLanguageToggle();
}

const crmStatusKeyMap = {
  New: 'crmStatusNew',
  Qualified: 'crmStatusQualified',
  'Quote sent': 'crmStatusQuoteSent',
  'Awaiting response': 'crmStatusAwaiting',
  Won: 'crmStatusWon',
  Lost: 'crmStatusLost'
};

const crmStatusSlugMap = {
  New: 'new',
  Qualified: 'qualified',
  'Quote sent': 'quote',
  'Awaiting response': 'awaiting',
  Won: 'won',
  Lost: 'lost'
};

const crmMetricConfig = [
  { key: 'crmMetricLeads', field: 'activeLeads' },
  { key: 'crmMetricQuotes', field: 'quotesPending' },
  { key: 'crmMetricRevenue', field: 'revenueAtRisk', formatter: 'currency' },
  { key: 'crmMetricConversion', field: 'conversionRate', formatter: 'percent' }
];

const crmFallbackData = {
  metrics: {
    activeLeads: 12,
    quotesPending: 5,
    revenueAtRisk: 3200,
    conversionRate: 42
  },
  pipeline: [
    { status: 'New', count: 4, percent: 20 },
    { status: 'Qualified', count: 3, percent: 15 },
    { status: 'Quote sent', count: 3, percent: 15 },
    { status: 'Awaiting response', count: 2, percent: 10 },
    { status: 'Won', count: 5, percent: 25 },
    { status: 'Lost', count: 3, percent: 15 }
  ],
  tasks: [
    {
      title: {
        en: 'Confirm quote follow-up for Maison Dupont',
        fr: 'Confirmer le suivi devis pour Maison Dupont'
      },
      owner: 'Amira',
      due: 'Today'
    },
    {
      title: {
        en: 'Prepare onboarding checklist for LumiÃ¨re Offices',
        fr: 'PrÃ©parer la check-list pour LumiÃ¨re Offices'
      },
      owner: 'Thomas',
      due: 'Tomorrow'
    },
    {
      title: {
        en: 'Send availability recap to Cafe Nouvelle',
        fr: 'Envoyer le rÃ©capitulatif Ã  Cafe Nouvelle'
      },
      owner: 'Lina',
      due: 'Friday'
    }
  ],
  bookings: [
    {
      id: 'bk-1001',
      client: 'Maison Dupont',
      service: 'Deep clean + windows',
      date: '2024-10-18',
      value: 640,
      status: 'Quote sent',
      owner: 'Amira',
      source: 'Instagram',
      nextStep: 'Follow-up call'
    },
    {
      id: 'bk-1002',
      client: 'LumiÃ¨re Offices',
      service: 'Weekly maintenance',
      date: '2024-10-21',
      value: 1200,
      status: 'Qualified',
      owner: 'Thomas',
      source: 'Referral',
      nextStep: 'Prepare contract'
    },
    {
      id: 'bk-1003',
      client: 'Cafe Nouvelle',
      service: 'Kitchen sanitation',
      date: '2024-10-16',
      value: 420,
      status: 'Awaiting response',
      owner: 'Lina',
      source: 'Website',
      nextStep: 'Send reminder'
    }
  ]
};

const getTranslation = (key) => translations[currentLanguage]?.[key] || translations.en?.[key] || key;

const formatCrmCurrency = (value) => {
  const locale = currentLanguage === 'fr' ? 'fr-FR' : 'en-US';
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: 'EUR',
    maximumFractionDigits: 0
  }).format(Number(value) || 0);
};

const formatCrmValue = (value, formatter) => {
  if (formatter === 'currency') {
    return formatCrmCurrency(value);
  }
  if (formatter === 'percent') {
    const safeValue = Number(value) || 0;
    return `${safeValue}%`;
  }
  return Number(value) || 0;
};

const getCrmStatusLabel = (status) => {
  const key = crmStatusKeyMap[status];
  return key ? getTranslation(key) : status;
};

const formatCrmDate = (date) => {
  if (!date) return '';
  const locale = currentLanguage === 'fr' ? 'fr-FR' : 'en-US';
  const parsed = new Date(date);
  if (Number.isNaN(parsed.getTime())) return date;
  return parsed.toLocaleDateString(locale, {
    month: 'short',
    day: 'numeric'
  });
};

const renderCrmMetrics = (metrics = {}) => {
  const container = document.querySelector('[data-crm-metrics]');
  if (!container) return;

  container.innerHTML = crmMetricConfig.map((metric) => `
    <div class="crm-metric">
      <span data-i18n="${metric.key}"></span>
      <strong>${formatCrmValue(metrics[metric.field], metric.formatter)}</strong>
    </div>
  `).join('');

  applyTranslations();
};

const renderCrmPipeline = (pipeline = []) => {
  const container = document.querySelector('[data-crm-pipeline]');
  if (!container) return;

  container.innerHTML = pipeline.map((stage) => `
    <div class="crm-pipeline-item">
      <div class="crm-pipeline-top">
        <span>${getCrmStatusLabel(stage.status)}</span>
        <span>${stage.count}</span>
      </div>
      <div class="crm-pipeline-bar"><span style="width: ${stage.percent || 0}%"></span></div>
    </div>
  `).join('');
};

const renderCrmTasks = (tasks = []) => {
  const container = document.querySelector('[data-crm-tasks]');
  if (!container) return;

  if (!tasks.length) {
    container.innerHTML = `<li class="crm-empty">${getTranslation('crmEmptyState')}</li>`;
    return;
  }

  container.innerHTML = tasks.map((task) => `
    <li class="crm-task-item">
      <strong>${task.title?.[currentLanguage] || task.title?.en || task.title || ''}</strong>
      <div class="crm-task-meta">
        <span>${getTranslation('crmTaskOwner')}: ${task.owner}</span>
        <span>${getTranslation('crmTaskDue')}: ${task.due}</span>
      </div>
    </li>
  `).join('');
};

const crmTableHeader = `
  <div class="crm-row crm-row-header">
    <span data-i18n="crmTableClient"></span>
    <span data-i18n="crmTableService"></span>
    <span data-i18n="crmTableStatus"></span>
    <span data-i18n="crmTableValue"></span>
    <span data-i18n="crmTableOwner"></span>
    <span data-i18n="crmTableActions"></span>
  </div>
`;

const renderCrmBookings = (bookings = []) => {
  const container = document.querySelector('[data-crm-table]');
  if (!container) return;

  if (!bookings.length) {
    container.innerHTML = `${crmTableHeader}<div class="crm-empty" data-i18n="crmEmptyState"></div>`;
    applyTranslations();
    return;
  }

  const rows = bookings.map((booking) => {
    const statusLabel = getCrmStatusLabel(booking.status);
    const statusSlug = crmStatusSlugMap[booking.status] || 'new';

    return `
      <div class="crm-row">
        <div>
          <strong>${booking.client}</strong>
          <small>${booking.source || ''}</small>
        </div>
        <div>
          <strong>${booking.service}</strong>
          <small>${formatCrmDate(booking.date)}</small>
        </div>
        <div>
          <span class="crm-status-pill status-${statusSlug}">${statusLabel}</span>
        </div>
        <div>
          <strong>${formatCrmCurrency(booking.value)}</strong>
          <small>${booking.nextStep || ''}</small>
        </div>
        <div>
          <strong>${booking.owner}</strong>
          <small>#${booking.id}</small>
        </div>
        <div class="crm-actions-group">
          <button class="button ghost" type="button" data-crm-action="edit" data-crm-id="${booking.id}" data-i18n="crmActionEdit"></button>
          <button class="button ghost" type="button" data-crm-action="delete" data-crm-id="${booking.id}" data-i18n="crmActionDelete"></button>
        </div>
      </div>
    `;
  }).join('');

  container.innerHTML = crmTableHeader + rows;
  applyTranslations();
};

const resetCrmForm = (form) => {
  if (!form) return;
  form.reset();
  form.querySelector('[data-crm-id]').value = '';
  form.dataset.mode = 'create';
  const submitButton = form.querySelector('[data-crm-submit]');
  if (submitButton) {
    submitButton.setAttribute('data-i18n', 'crmFormSubmit');
  }
  const cancelButton = form.querySelector('[data-crm-cancel]');
  if (cancelButton) {
    cancelButton.hidden = true;
  }
  applyTranslations();
};

const populateCrmForm = (form, booking) => {
  if (!form || !booking) return;
  form.querySelector('[data-crm-id]').value = booking.id;
  form.elements.client.value = booking.client;
  form.elements.service.value = booking.service;
  form.elements.date.value = booking.date;
  form.elements.value.value = booking.value;
  form.elements.status.value = booking.status;
  form.elements.owner.value = booking.owner;
  form.elements.source.value = booking.source;
  form.elements.nextStep.value = booking.nextStep;
  form.dataset.mode = 'edit';

  const submitButton = form.querySelector('[data-crm-submit]');
  if (submitButton) {
    submitButton.setAttribute('data-i18n', 'crmFormUpdate');
  }
  const cancelButton = form.querySelector('[data-crm-cancel]');
  if (cancelButton) {
    cancelButton.hidden = false;
  }
  applyTranslations();
};

const fetchCrmOverview = async () => {
  const response = await fetch('/api/crm/overview');
  if (!response.ok) {
    throw new Error('Failed to fetch CRM overview');
  }
  return response.json();
};

const fetchCrmBookings = async () => {
  const response = await fetch('/api/crm/bookings');
  if (!response.ok) {
    throw new Error('Failed to fetch CRM bookings');
  }
  const payload = await response.json();
  return payload.bookings || [];
};

const saveCrmBooking = async (booking, mode) => {
  const url = mode === 'edit' ? `/api/crm/bookings/${booking.id}` : '/api/crm/bookings';
  const method = mode === 'edit' ? 'PUT' : 'POST';

  const response = await fetch(url, {
    method,
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(booking)
  });

  if (!response.ok) {
    throw new Error('Unable to save booking');
  }

  return response.json();
};

const deleteCrmBooking = async (id) => {
  const response = await fetch(`/api/crm/bookings/${id}`, { method: 'DELETE' });
  if (!response.ok) {
    throw new Error('Unable to delete booking');
  }
  return response.json();
};

document.addEventListener('DOMContentLoaded', () => {
  const toggle = document.querySelector('[data-lang-toggle]');
  if (toggle) {
    toggle.addEventListener('click', () => {
      const nextLanguage = currentLanguage === 'en' ? 'fr' : 'en';
      setLanguage(nextLanguage);
    });
  }

  const query = new URLSearchParams(window.location.search);
  const authRequired = query.get('auth') === 'required';
  document.querySelectorAll('[data-auth-banner]').forEach((banner) => {
    banner.hidden = !authRequired;
  });

  applyTranslations();
  updateLanguageToggle();
});

document.addEventListener('DOMContentLoaded', () => {
  const metricsContainer = document.querySelector('[data-crm-metrics]');
  if (!metricsContainer) return;

  const form = document.querySelector('[data-crm-form]');
  const refreshButton = document.querySelector('[data-crm-refresh]');
  const newButton = document.querySelector('[data-crm-new]');
  const cancelButton = document.querySelector('[data-crm-cancel]');
  const table = document.querySelector('[data-crm-table]');

  const refreshCrm = async () => {
    try {
      const overview = await fetchCrmOverview();
      renderCrmMetrics(overview.metrics);
      renderCrmPipeline(overview.pipeline);
      renderCrmTasks(overview.tasks);
      renderCrmBookings(overview.bookings);
    } catch (error) {
      console.warn('CRM overview unavailable', error);
      renderCrmMetrics(crmFallbackData.metrics);
      renderCrmPipeline(crmFallbackData.pipeline);
      renderCrmTasks(crmFallbackData.tasks);
      renderCrmBookings(crmFallbackData.bookings);
    }
  };

  refreshCrm();

  refreshButton?.addEventListener('click', () => {
    refreshCrm();
  });

  newButton?.addEventListener('click', () => {
    resetCrmForm(form);
    form?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });

  cancelButton?.addEventListener('click', () => resetCrmForm(form));

  form?.addEventListener('submit', async (event) => {
    event.preventDefault();

    const payload = {
      id: form.querySelector('[data-crm-id]').value,
      client: form.elements.client.value.trim(),
      service: form.elements.service.value.trim(),
      date: form.elements.date.value,
      value: form.elements.value.value,
      status: form.elements.status.value,
      owner: form.elements.owner.value.trim(),
      source: form.elements.source.value.trim(),
      nextStep: form.elements.nextStep.value.trim()
    };

    try {
      await saveCrmBooking(payload, form.dataset.mode);
      resetCrmForm(form);
      const bookings = await fetchCrmBookings();
      renderCrmBookings(bookings);
      const overview = await fetchCrmOverview();
      renderCrmMetrics(overview.metrics);
      renderCrmPipeline(overview.pipeline);
    } catch (error) {
      console.warn('CRM save failed', error);
    }
  });

  table?.addEventListener('click', async (event) => {
    const button = event.target.closest('[data-crm-action]');
    if (!button) return;
    const action = button.dataset.crmAction;
    const id = button.dataset.crmId;

    try {
      if (action === 'edit') {
        const bookings = await fetchCrmBookings();
        const booking = bookings.find((entry) => entry.id === id);
        populateCrmForm(form, booking);
        form?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }

      if (action === 'delete') {
        await deleteCrmBooking(id);
        const overview = await fetchCrmOverview();
        renderCrmMetrics(overview.metrics);
        renderCrmPipeline(overview.pipeline);
        renderCrmTasks(overview.tasks);
        renderCrmBookings(overview.bookings);
      }
    } catch (error) {
      console.warn('CRM action failed', error);
    }
  });
});

const GAMIFICATION_ACTIONS = {
  RECIPE_CREATED: 'RECIPE_CREATED',
  SUSTAINABILITY_ACTION: 'SUSTAINABILITY_ACTION',
  SIEBEL_SYNC: 'SIEBEL_SYNC',
  SESSION_LOGIN: 'SESSION_LOGIN',
  COOKING_CHALLENGE: 'COOKING_CHALLENGE',
  SESSION_MILESTONE: 'SESSION_MILESTONE',
  CARBON_OFFSET: 'CARBON_OFFSET',
  REGION_DISCOVERY: 'REGION_DISCOVERY',
  ASTEROID_SCAN: 'ASTEROID_SCAN'
};

const defaultGamificationState = {
  level: 1,
  totalXP: 0,
  xpIntoLevel: 0,
  xpToNextLevel: 100,
  gold: 0,
  gems: 0,
  streak: 0,
  questProgress: []
};

class GamificationClient {
  constructor() {
    this.state = { ...defaultGamificationState };
  }

  async init() {
    try {
      const response = await fetch('/api/gamification/progress');
      if (!response.ok) return;
      const payload = await response.json();
      if (payload.state) {
        this.state = payload.state;
        renderGamificationState(this.state);
        renderQuestList(this.state.questProgress);
      }
    } catch (error) {
      console.warn('Failed to initialise gamification', error);
    }
  }

  async recordAction(actionType, metadata = {}) {
    if (!actionType) {
      return;
    }

    try {
      const response = await fetch('/api/gamification/actions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ actionType, metadata })
      });

      if (!response.ok) {
        const errorBody = await response.json().catch(() => ({}));
        throw new Error(errorBody.error || `Action ${actionType} indisponible`);
      }

      const payload = await response.json();
      if (payload.state) {
        this.state = payload.state;
        renderGamificationState(this.state);
        renderQuestList(this.state.questProgress);
      }

      if (payload.events?.length) {
        announceGamificationEvents(payload.events);
      }

      return payload;
    } catch (error) {
      console.error('Gamification error:', error);
      toastr.error(error.message || 'Impossible de valider cette action.');
      throw error;
    }
  }
}

const gamificationClient = new GamificationClient();

function renderGamificationState(state) {
  if (!state) return;

  const levelDisplay = document.getElementById('levelDisplay');
  const goldDisplay = document.getElementById('goldDisplay');
  const gemDisplay = document.getElementById('gemDisplay');
  const streakDisplay = document.getElementById('streakDisplay');
  const xpSummary = document.getElementById('xpSummary');
  const xpProgress = document.getElementById('xpProgress');

  if (levelDisplay) levelDisplay.textContent = state.level ?? 1;
  if (goldDisplay) goldDisplay.textContent = state.gold ?? 0;
  if (gemDisplay) gemDisplay.textContent = state.gems ?? 0;
  if (streakDisplay) streakDisplay.textContent = state.streak ?? 0;

  if (xpSummary) {
    const xpToNext = state.xpToNextLevel || 100;
    xpSummary.textContent = `${state.xpIntoLevel ?? 0} / ${xpToNext} XP`;
  }

  if (xpProgress) {
    const xpToNext = state.xpToNextLevel || 100;
    const progress = xpToNext ? Math.min(100, Math.round(((state.xpIntoLevel || 0) / xpToNext) * 100)) : 0;
    xpProgress.style.width = `${progress}%`;
  }
}

function renderQuestList(quests = []) {
  const questList = document.getElementById('questList');
  if (!questList) return;

  if (!quests.length) {
    questList.innerHTML = '<p class="quest-empty">Aucune quÃªte disponible pour le moment.</p>';
    return;
  }

  questList.innerHTML = quests.map((quest) => {
    const progressText = `${quest.progress}/${quest.target}`;
    const statusClass = quest.completed ? 'quest-status completed' : 'quest-status';
    const statusText = quest.completed ? 'TerminÃ©' : `En cours (${progressText})`;
    const progressWidth = Math.min(100, quest.progressPercent || 0);

    return `
      <div class="quest-card">
        <h3>${quest.title}</h3>
        <p>${quest.description}</p>
        <div class="quest-progress-bar"><span style="width: ${progressWidth}%"></span></div>
        <div class="quest-rewards">
          <span>+${quest.xpReward} XP</span>
          <span>+${quest.goldReward}ðŸ’°</span>
          ${quest.gemsReward ? `<span>+${quest.gemsReward}ðŸ’Ž</span>` : ''}
        </div>
        <span class="${statusClass}">${statusText}</span>
      </div>
    `;
  }).join('');
}

function announceGamificationEvents(events = []) {
  events.forEach((event) => {
    const message = typeof event === 'string' ? event : event.message;
    if (message) {
      toastr.success(message);
    }
  });
}

/* Chat */
document.addEventListener('DOMContentLoaded', function () {
  // Cache DOM elements for better performance
  const amountInput = document.getElementById('amount');
  const sendButton = document.getElementById('send-button');
  const message = document.getElementById('message');
  const addButton = document.getElementById('addButton');
  const itemsSection = document.querySelector('.items');
  const chatBox = document.getElementById('chat-box');
  const chatInput = document.getElementById('chat-input');
  const chatSend = document.getElementById('chat-send');
  const toggleLangButton = document.getElementById('toggle-lang');

  let currentLanguage = 'en'; // Default to English

  gamificationClient.init();

  // Language dictionary for internationalization (i18n)
  const dictionary = {
    en: {
      amountPlaceholder: "Enter Galactic Units",
      sendButton: "Send Units",
      addItem: "Add Galactic Recipe",
      chatPlaceholder: "Type your recipe message </div>...",
      sendingMessage: "Sending Galactic Units...",
      sentMessage: "Sent",
      errorAmount: "Please enter a valid amount.",
      errorItem: "Please enter a recipe name.",
      successAmount: "Galactic Units Sent",
      newItemAdded: "New Galactic Recipe added",
      errorEmptyMessage: "Please enter a message.",
      langToggle: "ðŸ‡ºðŸ‡¸ English / ðŸ‡«ðŸ‡· FranÃ§ais"
    },
    fr: {
      amountPlaceholder: "Entrez les UnitÃ©s Galactiques",
      sendButton: "Envoyer les UnitÃ©s",
      addItem: "Ajouter une Recette Galactique",
      chatPlaceholder: "Tapez votre message de recette...",
      sendingMessage: "Envoi des UnitÃ©s Galactiques...",
      sentMessage: "EnvoyÃ©",
      errorAmount: "Veuillez entrer un montant valide.",
      errorItem: "Veuillez entrer un nom de recette.",
      successAmount: "UnitÃ©s Galactiques EnvoyÃ©es",
      newItemAdded: "Nouvelle Recette Galactique ajoutÃ©e",
      errorEmptyMessage: "Veuillez entrer un message.",
      langToggle: "ðŸ‡ºðŸ‡¸ English / ðŸ‡«ðŸ‡· FranÃ§ais"
    }
  };

  // Translate the interface
  function translate() {
    amountInput.placeholder = dictionary[currentLanguage].amountPlaceholder;
    sendButton.textContent = dictionary[currentLanguage].sendButton;
    addButton.textContent = dictionary[currentLanguage].addItem;
    chatInput.placeholder = dictionary[currentLanguage].chatPlaceholder;
    toggleLangButton.textContent = dictionary[currentLanguage].langToggle;
  }

  // Language toggle function with fallback
  toggleLangButton.addEventListener('click', function () {
    currentLanguage = currentLanguage === 'en' ? 'fr' : 'en';
    translate();
  });

  translate(); // Initial translation for the default language

  // Send button click handler for sending units
  sendButton.addEventListener('click', function () {
    const amount = parseFloat(amountInput.value);

    if (isNaN(amount) || amount <= 0) {
      message.textContent = dictionary[currentLanguage].errorAmount;
      toastr.error(dictionary[currentLanguage].errorAmount);
      return;
    }

    message.textContent = dictionary[currentLanguage].sendingMessage;

    // Optimized animation logic
    let currentAmount = 0;
    const stepAmount = amount / 100; // Divide by 100 for a smooth transition
    const animationDuration = 1000; // milliseconds

    const intervalId = setInterval(() => {
      currentAmount = Math.min(currentAmount + stepAmount, amount);
      amountInput.value = currentAmount.toFixed(2);

      if (currentAmount >= amount) {
        clearInterval(intervalId);
        message.textContent = `${dictionary[currentLanguage].sentMessage} ${amount.toFixed(2)} U.G.`;
        toastr.success(`${dictionary[currentLanguage].successAmount}: ${amount.toFixed(2)} U.G.`);
        gamificationClient
          .recordAction(GAMIFICATION_ACTIONS.SUSTAINABILITY_ACTION, {
            bonusXp: Math.round(amount / 5),
            count: 1
          })
          .catch((error) => console.warn('Unable to record sustainability action', error));
      }
    }, animationDuration / 100); // Small intervals for smooth animation
  });

  // Create a new recipe
  function createRecipe(recipeName) {
    const recipe = document.createElement('div');
    recipe.classList.add('item');
    recipe.textContent = recipeName;
    return recipe;
  }

  // Add a new recipe to the items section
  async function addNewRecipe() {
    const newRecipeName = prompt(dictionary[currentLanguage].addItem);
    if (newRecipeName) {
      const newRecipe = createRecipe(newRecipeName);
      itemsSection.appendChild(newRecipe);
      toastr.info(`${dictionary[currentLanguage].newItemAdded}: ${newRecipeName}`);
      try {
        await gamificationClient.recordAction(GAMIFICATION_ACTIONS.RECIPE_CREATED, {
          recipeName: newRecipeName
        });
      } catch (error) {
        console.warn('Recipe quest update failed', error);
      }
    } else {
      toastr.error(dictionary[currentLanguage].errorItem);
    }
  }

  addButton.addEventListener('click', addNewRecipe);

  // Chat send button functionality
  chatSend.addEventListener('click', function () {
    const message = chatInput.value.trim();
    if (message) {
      addMessageToChat("You", message);
      chatInput.value = ''; // Clear input
    } else {
      toastr.error(dictionary[currentLanguage].errorEmptyMessage);
    }
  });

  // Send chat message on 'Enter' key press
  chatInput.addEventListener('keydown', function (event) {
    if (event.key === 'Enter') {
      chatSend.click();
    }
  });

  // Add message to the chat box
  function addMessageToChat(sender, message) {
    const messageElement = document.createElement('div');
    messageElement.textContent = `${sender}: ${message}`;
    chatBox.appendChild(messageElement);
    chatBox.scrollTop = chatBox.scrollHeight; // Auto scroll to the latest message
  }
});

window.gamifyAction = (actionType, metadata) => gamificationClient.recordAction(actionType, metadata);
window.gamificationState = () => ({ ...gamificationClient.state });

// Secure API call function with better error handling and optimization
async function secureFetch(url, authToken = '') {
  try {
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${authToken}`,
      },
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    return await response.json();
  } catch (error) {
    console.error('Fetch error:', error);
    toastr.error('Failed to fetch data. Try again later.');
    throw error;
  }
}

// Fetch asteroid data and display results
async function fetchAsteroids() {
  const date = document.getElementById('dateInput').value;
  if (!date) {
    toastr.warning('Please select a date.');
    return;
  }

  const apiKey = 'DEMO_KEY'; // Replace with your NASA API key
  const url = `https://api.nasa.gov/neo/rest/v1/feed?start_date=${date}&end_date=${date}&api_key=${apiKey}`;
  const asteroidResults = document.getElementById('asteroid-results');

  asteroidResults.innerHTML = '<p>Loading asteroids...</p>';

  try {
    const data = await secureFetch(url);
    asteroidResults.innerHTML = '';
    const asteroids = data.near_earth_objects[date];

    if (asteroids && asteroids.length > 0) {
      asteroids.forEach(asteroid => {
        const diameter = ((+asteroid.estimated_diameter.meters.estimated_diameter_min + +asteroid.estimated_diameter.meters.estimated_diameter_max) / 2).toFixed(2);
        const velocity = (+asteroid.close_approach_data[0].relative_velocity.kilometers_per_hour).toFixed(2);
        const missDistance = (+asteroid.close_approach_data[0].miss_distance.kilometers).toFixed(2);

        const asteroidDiv = document.createElement('div');
        asteroidDiv.className = 'result-item';
        asteroidDiv.innerHTML = `
          <h3>${asteroid.name}</h3>
          <p>Diameter: ${diameter} meters</p>
          <p>Velocity: ${velocity} km/h</p>
          <p>Miss Distance: ${missDistance} km</p>
        `;
        asteroidResults.appendChild(asteroidDiv);
      });
      gamificationClient
        .recordAction(GAMIFICATION_ACTIONS.ASTEROID_SCAN, { count: asteroids.length })
        .catch((error) => console.warn('Asteroid quest update failed', error));
    } else {
      asteroidResults.innerHTML = '<p>No asteroids found for this date.</p>';
    }
  } catch (error) {
    asteroidResults.innerHTML = '<p>Error retrieving data. Please try again later.</p>';
  }
}
